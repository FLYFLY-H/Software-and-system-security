# 实验报告四

## 实验内容
- 通过调试器监控计算器程序的运行，每当运行结果为666时，就改为999。
  - 提示：找到运行结果在内存中保存的地址。监控 “=” 按键消息等。

## 实验过程
- 打开windbg，`file`->`open execuable`->选择`windows\system32\calc.exe`，并且打开计算器
- 配置windbg的符号表，`file`->`symblo file path`->填入`cache*C:\symbols;srv*https://msdl.microsoft.com/download/symbols`,然后在windbg执行命令`.reload /f /i`强制加载所有的符号表。
- 首先对SetWindowText函数下断点，并且每当断点命中时，显示esp+0x8的内容，发现这个地址对应的就是我们在计算器输入的数字。`bp SetWindowTextW "du poi(esp+0x8);g"`<br>
![](poi.mp4)
- 编写一个脚本

```bash
# poi()取指针内的内容，然后将指针的内容赋值给name变量
as /mu ${/v:name} poi(esp+0x8)  

#进行字符串比较 如果name和666相同 就改为 999 否则输出name
#scmp进行字符串比较，@是不对字符串进行转义就按照
#ezu修改指针的内容，但是实际的值并没有改变，只是显示的内容变了
.if($scmp(@"${name}","666")==0){ezu poi(esp+0x8) "999";}.else{.echo ${name};}

# 程序继续运行
g
```
- 在windbg输入`bp SetWindowTextW "$<C:\\1.txt"`,断点设置好后输入`g`可以看见输入666时，显示999，但是继续进行计算还是用666这个值来计算的。<br>
![](calc.mp4)

## 实验问题
- 在选择用脚本进行调试之前，有尝试直接在命令行输入长串命令，但是失败了。请教了同学，我们猜测是Windbg的漏洞，也许指令太长转义不过来？但是尝试将指令缩小到只有`.if`语句仍然失败，暂时没有解决这个问题。